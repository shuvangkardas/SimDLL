# SimDLL

SimDLL is a Python wrapper for Simulink DLL simulation that provides an interface for running dynamic simulations with input/output structures. It's particularly useful for power systems and control systems simulations.

## Features

- Dynamic loading and handling of Windows DLLs generated by Simulink
- Automatic function detection and setup
- Support for complex input/output structures
- Step-by-step simulation capabilities
- Built-in plotting utilities
- Support for step changes in input parameters

## Installation

Place the `SimDLL.py` file in your project directory. Ensure you have the following dependencies installed:

```bash
pip install -i https://test.pypi.org/simple/ SimDLL
```

## Basic Usage

Here's a basic example of how to use SimDLL:

```python
from SimDLL import SimDLL
import ctypes
import numpy as np

# Define simulation parameters
step_size = 1/24e3  # timestep
duration = 2.0      # 2 second simulation

# Define input/output structures
class inputStruct(ctypes.Structure):
    _fields_ = [
        ("param", ctypes.c_float * 2),
        ("cmd", ctypes.c_float * 4)
    ]

class outputStruct(ctypes.Structure):
    _fields_ = [
        ("out_gfm", ctypes.c_double * 20),
        ("out_gfl", ctypes.c_double * 20)
    ]

# Initialize SimDLL
dll_path = "./IBR_1GFM_1GFL.dll"
inverter = SimDLL(dll_path, 
                 inputStruct=inputStruct, 
                 outputStruct=outputStruct, 
                 dt=step_size)

# Define inputs with step changes
inputs = {
    'param': [1.0, 10.0],
    'cmd': [
        {'step_time': 0.5, 'initial': 0.0, 'final': 1.0},    # Enable step
        {'step_time': 0.5, 'initial': 0.0, 'final': 0.5},    # Pref step
        {'step_time': 0.5, 'initial': 0.1, 'final': 0.2},    # Qref step
        {'step_time': 0.5, 'initial': 0.0, 'final': 1.0},    # Vref step
    ]
}

# Run simulation
result = inverter.run_simulation(inputs, duration)
```

## Plotting Results

SimDLL provides two main plotting utilities:

### Basic Plotting

```python
from SimDLL import plot_data_from_map

# Define data mapping
datamap = {
    "time": 0,
    "Vabc": [1, 2, 3],
    "Iabc": [4, 5, 6],
    "PQgen": [7, 8],
    "Freq": 9,
    "wt": 10,
    "Vdq": [11, 12, 13, 14],
    "ILdq": [15, 16, 17, 18],
    "Vdc": [19]
}

# Plot single dataset
plot_data_from_map(result['out_gfm'], datamap)
```

### Combined Plotting

```python
from SimDLL import plot_combined_from_map

# Define combined data mapping
datamap_combined = {
    "time": 0,
    "Pgen": 7,
    "Qgen": 8,
    "Freq": 9,
    "Vd": [11, 13],
    "Vq": [12, 14],
    "ILd": [15, 17],
    "ILq": [16, 18],
    "Vdc": [19]
}

# Plot multiple datasets
dataset = [result['out_gfm'], result['out_gfl']]
plot_combined_from_map(dataset, datamap_combined, time_array)
```

### Using DasPlotter

```python
from SimDLL import DasPlotter

# Create plotter instance for displaying plots
dp = DasPlotter(mode='show')
dataset = [result['out_gfm']]
dp.plot(datamap_combined, dataset, time_array, title="IBR Performance")

# Create plotter instance for saving plots
dp2 = DasPlotter(mode='save', orientation='vertical')
dataset = [result['out_gfm'], result['out_gfl']]
dp2.plot(datamap_combined, dataset, time_array, title="IBR Performance")
```

## API Reference

### SimDLL Class

```python
SimDLL(dll_path, inputStruct=None, outputStruct=None, dt=1/24e3)
```

Parameters:
- `dll_path`: Path to the DLL file
- `inputStruct`: ctypes Structure class defining input structure
- `outputStruct`: ctypes Structure class defining output structure
- `dt`: Time step for simulation (default: 1/24000)

Main Methods:
- `initialize()`: Initialize the simulation
- `step(inputs)`: Perform one simulation step
- `terminate()`: Terminate the simulation
- `run_simulation(inputs, duration)`: Run complete simulation
- `reset()`: Reset simulation to initial state

### Input Format

Inputs can be specified in two formats:

1. Direct values:
```python
inputs = {
    'param': [1.0, 2.0],
    'cmd': [0.0, 0.5, 0.1, 0.0]
}
```

2. Step changes:
```python
inputs = {
    'param': [1.0, 2.0],
    'cmd': [
        {'step_time': 0.5, 'initial': 0.0, 'final': 1.0},
        # ... more step definitions
    ]
}
```

## Error Handling

SimDLL includes custom exception classes:
- `SimDLLError`: General SimDLL errors
- `InvalidInputFieldError`: Invalid input field errors

Always use try-except blocks when working with SimDLL:

```python
try:
    inverter = SimDLL(dll_path, inputStruct, outputStruct)
    result = inverter.run_simulation(inputs, duration)
except SimDLLError as e:
    print(f"Simulation error: {e}")
except InvalidInputFieldError as e:
    print(f"Input error: {e}")
```

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Author Details:
Name: Shuvangkar Das
